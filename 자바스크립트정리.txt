dev
live-server client --host=localhsost --port=5500 --no-browser
npm run dev

--

1. 전역 객체 
window(브라우저 환경) = browser = viewport = global object(node) = *globalThis

*globalThis로 표준화하자는 말이 나와있기는 하지만 몇몇 브라우저는 globalThis를 지원하지 않는다


2. 내장 함수

- 이미 시스템에 정의되어 있는 함수로서 사용자가 정의하지 않아도 사용 가능하다

- 콘솔 창에 window를 치면 내장 함수 목록을 볼 수 있다

종류: alert(), confirm(), prompt(), log() 등


3. 문 vs 식

- 문
ㅇ 값을 반환하지 않는다 (ex: for 문, while 문 등)
ㅇ 문이 끝나면 세미콜론을 찍어 주는 것이 좋다

- 식
ㅇ 값을 반환해 준다 (ex: 단항식(x = 1;) 이항식 (1 + 1;) , 10 < 100; 등)


4. 선언과 할당

- 선언: let a; 
ㅇ a를 사용하겠다고 선언했다

- 할당: a = 1;
ㅇ a에게 값을 줬다


5. 변수와 상수

- 변수: 내용물을 바꿀 수 있는 상자
ㅇ var: 지금은 사용하지 않는 변수 / 하지만 자세히 알아 둬야 한다
ㅇ let

- 상수: 내용물을 바꿀 수 없는 상자
ㅇ const: 재할당이 불가능하므로, 선언과 동시에 할당을 해 주어야 한다


6. 엄격 모드

- es5 이후로 기존 기능 중 일부를 변경했는데 엄격 모드를 활성화하면 이 변경 사항이 활성화된다

- 활성화 방법: 'use strict'를 자바스크립트 코드의 최상단에 넣는다


7. 호이스팅

- 자바스크립트 환경은 모든 변수의 선언부를 찾아서 코드의 최상단으로 이동시키는데, 이것을 호이스팅이라고 한다

- var은 호이스팅이 될 때 초기값으로 undefined를 할당받는다. 반면 let, const는 초기값을 할당받지 않는다


8. 객체

- 하나의 데이터만 담을 수 있는 원시형과는 달리, 객체는 여러 가지 데이터를 담을 수가 있다

- 객체 안에는 '키(key): 값(value)'의 쌍으로 이루어진 프로퍼티를 넣을 수 있다.

-  다음을 참고하여 객체와 프로퍼티를 구분한다
let user = {     // 객체
  name: "John",  // 키: "name",  값: "John"
  age: 30        // 키: "age", 값: 30
};

- 객체를 만드는 방법
ㅇ let user = new Object( ); // 객체 생성자
ㅇ let user = { }; // 객체 리터럴

- user.name과 같이 (객체 이름).(프로퍼티 키) 형식의 점 표기법을 통해 프로퍼티 값을 읽을 수 있다

- 대괄호 표기법은 점 표기법과 달리 대괄호로 묶을 수 있기 때문에 어떤 문자열이 있던지 상관없이 동작한다
ㅇ 다음과 같이 사용할 수 있다
let key = "likes birds";
// user["likes birds"] = true; 와 같습니다.
user[key] = true;

- 객체 안의 함수는 mathod라고 부르며, 세 가지 형태가 있다*
(1) normal: function a:function( ){ }
(2) arrow: function a:( )=>{ }
(3) concise: function a( ){ } (가장 많이 쓰는 형태)
*자바스크립트의 호환성 유지를 위해 
(1)은 this가 없고 (2), (3)은 this가 있다
(2)는 this를 바인딩하지 않지만 (3)은 this를 바인딩한다


9. 자료형

(1) 숫자형
- 자바스크립트 숫자형의 특이한 점은 정수와 실수의 구분 없이 그냥 숫자형이다
- Infinity, -Infinity, NaN(Not a Number)도 숫자형에 포함된다
(2) 문자형
- ${ }안에 넣으면 원하는 변수나 표현식을 문자열 중간에 손쉽게 넣을 수 있다
(3) 불린형
(4) BigInt
- 2^53보다 큰 값을 나타낼 수 있다
- 정수 리터럴 끝에 n을 붙이면 만들 수 있다
(5) null
- 값이 비어 있다는 것을 보여 준다
(6) undefined

- 값이 할당되지 않았다는 것을 보여 준다
(7) 객체
(8) 심볼

- 고유한 식별자를 만들 때 사용한다

--------
- 조회는 typeof 연산자로 한다
ㅇ typeof null의 결과는 "object"이지만 null은 객체가 아니다. 하위 호환성을 위해 오류를 수정하지 않았다
ㅇ typeof (함수)의 결과는 "function"으로 나오지만 함수는 객체형에 속하므로 이 역시 오류다. 하지만 하위 호환성을 위해 수정되지 않았다


10. 형 변환

- 문자형으로의 변환
ㅇ alert 함수에서 문자형이 아닌 다른 자료형의 매개변수를 받으면 자동으로 문자형으로 변환된다
ㅇ 명시적인 변환 방법: String( ) 함수를 통해 문자열로 변활할 수 있다
ㅇ 암시적인 변환 방법: + '' 를 붙여 문자형으로 변환할 수 있다

- 숫자형으로의 변환
ㅇ "6" / "2"는 자동으로 숫자형으로 변환되어 계산된다
ㅇ 명시적인 변환 방법: Number( ) 함수를 이용한다
ㅇ 암시적인 변환 방법
(1) '123' * 1 // 숫자형 123으로 변환됨 이하 동문
(2) '123' / 1
(3) +'123'
ㅇ Number(null)은 0, Number(undefined)는 NaN, Number(true)는 1, Number(false)는 0으로 변환이 이루어진다

- 불린형으로의 변환
ㅇ 직관적으로 비어 있다고 느껴지는 값들은 false가 된다 (0, 빈 문자열, null, undefined, NaN 등)*
*주의해야 할 점은 문자열 "0"은 true다
ㅇ 명시적인 변환 방법: Boolean( ) 함수를 이용한다
ㅇ 암시적인 변환 방법: !를 사용한다*
*!이 홀수 개면 부정, !이 짝수 개면 긍정


11. 기본 연산자

- 자바스크립트에서 지원하는 연산자는 다음과 같다
ㅇ +
ㅇ -
ㅇ *
ㅇ /
ㅇ % (나머지)
ㅇ ** (거듭제곱)

- 덧셈은 피연산자 중 하나가 문자열이면 다른 하나도 문자열로 변환된다

- 하지만 뺄셈과 나눗셈은 문자열이 숫자로 자동 변환되어 연산이 실행된다

- 복합 할당 연산자
ㅇ
let n = 2;
n = n + 5;
n = n * 2;
에서
n += 5;
n *= 2;로 줄일 수가 있다
이것이 복합 할당 연산자이다 (+=, *=, /= 등)

- 증가, 감소 연산자
ㅇ 증가 연산자: 변수 뒤에 ++를 붙이면 1만큼 증가시킬 수 있다
ㅇ감소 연산자: 변수 뒤에 --를 붙이면 1만큼 감소시킬 수 있다
ㅇ 증가, 감소 연산자는 변수에만 사용할 수 있다
ㅇ 전위형과 후위형으로 또 나뉘게 되는데, 연산 후의 결과를 바로 반환하는 것은 전위형(++ 변수명)
연산은 실행되었지만 연산 전의 결과를 반환하는 것은 후위형(변수명 ++)이다 따라서 값을 반환하지 않는다면 둘의 차이는 없다


12. 비교 연산자

- 비교 연산자의 종류는 다음과 같다
ㅇ 보다 큼, 작음: >, <
ㅇ 크거나 같다, 작거나 같다: >=, <=
ㅇ 같음(동등): ==
ㅇ 같지 않음: !=

- 비교 연산자는 불린형의 반환 값을 가진다

- 문자열끼리도 비교할 수 있다 이때는 사전순*으로 비교하여 같은 순서의 인덱스의 문자끼리 무엇이 더 큰지 계산한다 이때 사전 뒤쪽의 문자열이 사전 앞쪽의 문자열보다 크게 계산되어진다
*정확히는 유니코드 순이다 자바스크립트는 대, 소문자 중 소문자를 더 크게 계산한다 

- 비교하려는 값의 자료형이 다르면 자바스크립트가 알아서 숫자형으로 변환시켜 계산한다 
ㅇ 예컨대 '2' > 1 이라면 문자형인 '2'는 숫자형으로 바뀌게 되고 결과적으로 참을 반환하게 된다
ㅇ 불린형의 경우에 true는 1, false는 0으로 계산되어진다

- 일치 연산자(===)
ㅇ 동등 연산자(==)은 0과 false를 구분하지 못한다 왜냐하면 false가 계산 시 숫자형으로 바뀌게 되어 0이 나오기 때문이다
ㅇ 일치 연산자는 형 변환 없이 값을 비교할 수 있다

- null과 undefined를 동등 연산자를 사용하여 null == undefined 라고 비교하게 되면 true가 나오게 된다 
숫자형으로 변환되면 각각 0과 NaN으로 다른 값이 나오지만 동등 연산자는 피연산자가 null이나 undefined면 형 변환을 하지 않는다 null과 undefined를 비교하는 경우에만 true를 반환하고 그 외의 경우에는 무조건 false를 반환한다
또한 null > 0(거짓)과 null >= 0(참)의 반환 값이 다른 이유는 >과 >=의 동작 방식에 차이가 있기 때문인데, null >= 0의 경우에는 null이 숫자형으로 변환되어 0이 되기 때문이다

- undefined는 0과 비교 연산을 하면 항상 false 값을 출력한다


13. if 문과 조건부 연산자(삼항식에서 쓰이는 연산자)

- if 문의 기본적인 구조는 다음과 같다

if( 조건식 ){
    (참일 때 실행되는 문)
}

- if 문에서는 조건식의 결과를 불린값으로 변환하여 참일 때 { } 안의 문을 실행시킨다

- else if로 조건식을 여러 개 처리할 수 있으며, 모든 조건식들이 거짓일 때는 else로 처리해 줄 수 있다

if(조건식){
    (문)
}else if(조건식){
    (문)
}else(조건식){
    (문)
}

- 조건부 연산자 ('?')
ㅇ 피연산자가 세 개인 조건부 연산자를 삼항 연산자라고 한다
ㅇ 다음과 같이 표현할 수 있다
let result = (조건식) ? value1 : value2;

조건식이 참이라면 value1이, 거짓이라면 value2가 반환된다
ㅇ 물음표 연산자를 여러 개 연결하면 여러 개의 조건을 처리할 수 있다 예시는 다음과 같다

let message = (a < 10) ? 'hi' :
    (a < 40) ? 'hello' :
    (a < 80) ? '안녕하세요' :
    '안녕히 가세요';

ㅇ 조건부 연산자를 이용하는 삼항식은 if문과 비슷한 흐름으로 계산되는 것처럼 보인다 따라서 삼항식을 if문으로 바꾸거나 if문을 삼항식으로 바꾸는 것이 가능하다 하지만 식과 문의 차이가 있으니 문에서 값을 반환하고 싶을 때는 return을 넣어 줘야 한다


14. 논리 연산자

- 자바스크립트에는 세 가지 종류의 논리 연산자가 존재한다
(1) || (OR)
(2) && (AND)
(3) ! (NOT)

(1) ||은 OR 연산자로, 인수 중 하나라도 참이면 참이고 둘 다 거짓일 때는 거짓을 반환한다
ㅇ 다음과 같은 경우,

result = value1 || value2 || value3;

왼쪽부터 차례대로 평가하며, 각 피연산자를 불린형으로 변환하고 참으로 판별되면 연산을 멈추고 해당 피연산자의 변환 전 원래 값을 반환한다
이때 모두 거짓인 경우에는 마지막 피연산자를 반환한다

(2) &&은 AND 연산자로, 인수가 모두 참일 때만 참을 반환하고 그 외의 경우는 모두 거짓이다

ㅇ 다음과 같은 경우,

result = value1 && value2 && value3;

역시 왼쪽부터 차례대로 평가하며, 각 피연산자를 불린형으로 변환한다. OR 연산자와는 반대로 변환 후 값이 거짓일 때 평가를 멈추고 해당 피연산자의 변환 전 원래 값을 반환한다
모든 피연산자가 참인 경우에는 마지막 피연산자가 반환된다

(3) !은 NOT 연산자로, 구조는 매우 간단하다

result = !value;

value의 값이 참이라면 NOT 연산자로 인해 거짓으로 반환되고, 거짓이면 참으로 반환된다

!!value가 되면 원래의 불린형 값으로 돌아오게 된다


15. nullish 병합 연산자 '??'

- a ?? b의 결과는 다음과 같다

a가 null도 아니고 undefined도 아니면 a, 그 외는 b로 반환된다 
이것을 조건부 연산자로 처리하면 다음과 같다

x = (a !== null && a !== undefined) ? a :
    b;

- ??과 ||는 비슷하게 동작하는 것 같다 하지만 차이점이 있다
ㅇ ||는 첫 번째 참값을 반환한다
ㅇ ??는 첫 번째로 '정의된' 값을 반환한다

let height = 0;

alert(height || 100); // 100
alert(height ?? 100); // 0

에서,
||는 height가 불린형으로 바뀌면서 거짓이 되기 때문에 100이 반환되고
??는 height에 정의된 값이 있으므로 0이 반환된다


16. 반복문 (while, for)

- while 반복문의 구조는 다음과 같다

let i = 0(i의 초기값 설정);

while (i < 3)(i 로 통제하는 조건식) {
    alert (i)(조건에 부합하지 않을 때까지 실행되는 문)
    i++(i를 얼마만큼 증가시킬 것인지 통제하는 식)
}

ㅇ i++이 없었다면 반복문은 무한 루프에 빠지게 된다

- do while 반복문의 구조는 다음과 같다

do{
    반복문 본문
} while (condition);

이때 본문이 먼저 실행되고, 조건이 확인된 후 조건이 참인 동안 본문이 계속 실행된다

ㅇ do while은 조건이 참인지 아닌지에 상관없이 본문을 최소 한 번이라도 실행시키고 싶을 때만 사용한다

- for 반복문의 구조는 다음과 같다

for (begin; condition; step){
    반복문 본문
}

ㅇ begin; condition; step은 각각 초기값, 조건, 반복문 시행 방법을 의미한다. 예시는 다음과 같다

for (let i = 0; i < 3; i++) {
  console.log(i);
}

- for 문의 구성 요소를 생략하는 것도 가능하다. 하지만 생략할 때에도 ;(세미콜론)은 넣어 줘야 반복문이 정상적으로 실행된다.

- 반복문을 빠져나오기 위해 break를 사용할 수 있다

- continue 지시자는 전체 반복문을 멈추지 않고 현재 실행 중인 이터레이션을 멈춘 뒤 다음 이터레이션을 강제로 실행시킨다. continue를 사용한 반복문을 다음과 같다

for (let i = 0; i < 10; i++) {
  if (i % 2 == 0) continue;
  alert(i); // 1, 3, 5, 7, 9가 차례대로 출력됨
}

- 삼항 연산자 ?의 오른쪽에는 break나 continue가 올 수 없다

- 레이블은 for문 앞에서 (레이블 이름): 으로 쓸 수가 있고 break (레이블 이름); 하면 반복문을 빠져나오게 해 준다


17. switch문

- 복수의 if 조건문은 switch문으로 바꿀 수 있다 구조는 다음과 같다

let 매개변수 x = ~;

switch(매개변수 x) {
  case 'value1':  // if (x === 'value1')
    (일치하면 실행되는 문)
    [break]

  case 'value2':  // if (x === 'value2')
    (일치하면 실행되는 문)
    [break]

  default:
    (일치하면 실행되는 문)
    [break]
}

매개변수와 각 case의 값(value)들을 비교하고 일치하면 해당 case의 문이 실행된다

- break가 없으면 일치하는 값을 찾아도 뒤로 계속 실행된다

- 여러 개의 case를 묶어서 사용할 수 있다 예시는 다음과 같다

  case 3:
  case 5:
    alert('계산이 틀립니다!');
    alert("수학 수업을 다시 들어보는걸 권유 드립니다.");
    break;


18. 오래된 var

- var은 블록 스코프가 없다 var로 선언한 변수는 함수 스코프이거나 전역 스코프이다. 따라서 블록 밖에서 접근이 가능하다

- var는 변수의 중복 선언을 허용한다

- var는 호이스팅되었을 때 초기값으로 undefined를 할당받는다

- var의 스코프가 블록 레벨이 아니기 때문에, 개발자들은 '즉시 실행 함수 표현식(IIFE)'을 사용하여 임의로 var를 위한 블록 레벨 스코프를 만들었다


19. 함수

- 함수 선언 방식은 다음과 같다

function name(매개변수){
    함수 본문
}

위 함수 호출은 name()으로 가능하다

- 함수에서 선언한 변수는 지역 변수라고 하며, 함수 안에서만 접근할 수 있다

function name(매개변수){
    let message = '안녕하세요';
}

위 함수에서 message는 지역 변수가 되어, 함수 밖에서 console.log(message);를 하면 message가 정의되지 않았다는 에러가 뜨게 된다

- 반면 함수 내부에서 함수 외부에서 선언된 변수에 접근할 수 있다

let userName = 'gildong';

function showMessage(){
    let message = 'hello, ' + userName;
    console.log(message);
}

showMessage();

위 함수는 콘솔창을 열어 보면 hello, gildong이 출력된다. userName은 함수 밖에서 선언되었지만 함수가 외부 변수에 접근할 수 있기 때문이다

- 함수에선 외부 변수에 접근하는 것뿐만 아니라 수정도 가능하다

let userName = 'gildong';

function showMessage(){
    userName = 'gaeddong';
    let message = 'hello, ' + userName;
    console.log(message);
}

console.log(userName);

showMessage();

console.log(userName);

위 함수에서 console.log(userName);은 아직 함수 호출 전이므로 gildong이 찍히게 되지만 함수 호출 후에 다시 콘솔에 찍게 되면 gaeddong으로 바뀌어 있는 것을 확인할 수 있다

- 만약 함수 내부에 외부 변수와 동일한 이름의 변수가 선언되면 함수 외부에서 함수를 호출하여도 값이 변하지 않는다

let userName = 'gildong';

function showMessage(){
    let userName = 'gaeddong';
    let message = 'hello, ' + userName;
    console.log(message);
}

console.log(userName);

showMessage();

console.log(userName);

함수 내부에서는 hello, gaeddong이 찍히지만 함수를 호출하고 나서 콘솔에 username을 찍어 보면 내부에서 바꾼 값으로 출력되지 않았다는 것을 확인할 수 있다

- 함수 외부에서 선언된 변수를 전역 변수라고 부른다. 지역 변수를 선언하는 것이 좋지만 경우에 따라 전역 변수를 사용하는 것이 유리할 때도 있다

- 매개 변수는 임의의 데이터를 함수 안에 전달할 수 있다. parameter(인자)라고 부르기도 한다 다음과 같이 사용할 수 있다

function showMessage(name, text){
    console.log(name + ': ' + text);
}

showMessage('gildong', 'hello');

위 함수에서 매개 변수(인자)는 name, text가 되고 실행 결과는 gildong: hello 가 된다

- 함수 호출 시 매개변수에 인수를 전달하지 않으면 값이 undefined로 할당된다. 매개변수가 2개라도 인수를 하나만 넣어서 호출할 수도 있다. undefined로 할당되지 않게 하려면 =을 사용해 기본값을 정해 줄 수가 있다

function showMessage(name, text = 'blank'){
    console.log(from + ':' + text);
}

showMessage('gildong');

- 함수는 호출했을 때 return을 이용하여 특정 값을 반환하게 할 수 있다. return은 함수 내 어디서든 사용할 수 있으며, 하나의 함수 안에서도 여러 개의 return 문이 올 수 있다

function checkAge(age) {
  if (age >= 18) {
    return true;
  } else {
    return confirm('보호자의 동의를 받으셨나요?');
  }
}

let age = prompt('나이를 알려주세요', 18);

if ( checkAge(age) ) {
  alert( '접속 허용' );
} else {
  alert( '접속 차단' );
}

ㅇ return 문이 없거나 return 지시자만 있는 함수는 undefined를 반환한다
ㅇ return 문 뒤로 줄을 바꿔 코드를 작성하면 원하는 값을 반환받지 못한다. 따라서 return 문 뒤로 줄 바꿈을 하고 싶을 때에는 괄호를 써서 묶어 주는 것이 필요하다

- 함수는 어떤 동작을 하는지 설명할 수 있는 간결하고 명확한 이름을 가지는 것이 좋다.

- 함수는 함수 이름에 언급된 동작 하나만 실행하도록 코드를 짜야 한다


20. 배열

- 순서가 있는 컬렉션을 다뤄야 할 때 객체를 사용하면 순서와 관련된 매서드가 없어 편리하지 않다. 이럴 때 순서가 있는 컬렉션을 저장할 때 쓰는 자료 구조인 배열을 사용할 수 있다

- 배열은 다음과 같은 방법으로 만들 수 있다

1. let arr = new Array();
2. let arr = [];

- 각 배열 요소는 0부터 시작하는 인덱스를 가진다. 인덱스는 배열 내 순서를 의미한다

- 배열 내 특정 요소를 추출하고 싶다면 대괄호 안에 해당 인덱스 번호를 넣어 주면 된다 (ex: fruits[0], userName[2])

- length를 이용하면 배열에 담긴 요소가 몇 개인지 알아낼 수 있다 (ex: console.log(fruits.length);)

- 배열 요소의 자료형엔 제약이 없다. 문자형, 숫자형, 불린형, 함수 등 다양한 자료형의 요소가 올 수 있다

- 배열의 마지막 요소는 객체와 마찬가지로 쉼표로 끝낼 수 있다

- 배열은 큐와 스택이라는 자료 구조를 가진다

ㅇ 큐에서 사용하는 주요 연산은 push와 shift가 있다.
ㅇ push는 맨 끝에 요소를 추가해 주며, shift는 맨 앞의 요소를 꺼내고 나서 제거한 뒤 있는 요소들을 앞으로 밀어 준다

ㅇ 스택에서 주로 사용하는 연산은 unshift와 pop이 있다
ㅇ pop은 스택의 끝 요소를 추출하고, 이후에는 배열에서 해당 요소가 사라진다
ㅇ unshift는 배열 앞에 요소를 추가한다
ㅇ 스택을 사용하면 가장 나중에 집어 넣은 요소가 먼저 나오고, 큐를 사용하면 먼저 집어 넣은 요소가 먼저 나온다

ㅇ 사용 방법은 .push(해당 요소), .pop(), .shift()와 같이 배열 이름 뒤에 .을 찍고 원하는 매서드 명을 쓴 뒤 ()로 묶어 사용한다

- 배열의 본질은 객체이므로, 객체처럼 동작하게 된다

- 성능적인 측면에서 보았을 때, push와 pop은 빠르지만 shift와 unshift는 느리다

- 배열을 순회할 때 for 문과 같은 반복문을 주로 사용한다. for 문을 사용한 사례는 다음과 같다

let arr = ["사과", "오렌지", "배"];

for (let i = 0; i < arr.length; i++) {
  alert( arr[i] );
}

이렇게 되면 alert 창에 사과, 오렌지, 배가 하나씩 뜨게 되며 순회 시에 인덱스를 사용한다

for of 문을 사용하여 다음과 같이 순회할 수도 있다

let fruits = ["사과", "오렌지", "자두"];

for (let fruit of fruits) {
  alert( fruit );
}

for of 문은 인덱스를 얻을 수 없고 값만 얻을 수 있다

- 배열은 length 프로퍼티를 사용할 수 있다. length 프로퍼티의 인덱스는 1부터 시작한다. 수동으로 length의 값을 줄이면 그 다음 인덱스의 값들이 사라지게 되니 주의해야 한다

- new Array();를 이용하여 다음과 같이 배열을 만들 수 있다

let arr = new Array('사과', '배', '오렌지');

조금 더 보편적인 방법은 대괄호를 이용하는 것이다

- 배열 안에 또 다른 배열을 요소로써 넣을 수 있다. 이것을 다차원 배열이라고 한다. 주로 행렬을 저장하는 용도로 쓰인다


21. 함수 표현식

- 자바스크립트는 함수를 특별한 종류의 '값'으로 취급한다

- 변수에는 함수 실행의 결과값뿐만 아니라 함수 본문을 담을 수가 있다. 그래서 함수를 담은 변수를 함수처럼 사용할 수가 있다

function sayHi(){
  return 'Say Hi';
}

a = sayHi(); // 함수 실행값이 담김, Say Hi
b = sayHi; // 함수 본문이 담김

console.log(b())

- 함수 선언식(fuction a(){})는 호이스팅될 때 함수 본문이 함께 호이스팅되지만, 함수 표현식(const b = function (){})은 호이스팅되어도 함수 본문은 TDZ에 들어가 있기 때문에 호출해도 함수 본문은 나타나지 않는다

- 함수 표현식 끝에 세미 콜론은 함수 표현식이 값의 역할을 하기 때문에 구문의 끝을 표현하기 위해 찍어 준다

- 함수에 인수에 담긴 함수를 콜백 또는 콜백 함수라고 한다 예시는 다음과 같다

function ask(question, yes, no){
  if(confirm(question)){
    yes()
    }else{
    no();
  }
}

function showOk(){
  alert("동의하셨습니다.");
}

function showCancel(){
  alert("취소 버튼을 누르셨습니다.");
}

ask("동의하십니까?", showOk, showCancel)

ㅇ 이 함수는 다음과 같이 줄여서 쓸 수 있다

function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "동의하십니까?",
  function() { alert("동의하셨습니다."); },
  function() { alert("취소 버튼을 누르셨습니다."); }
);

인수 속에 담긴 함수들에 이름이 없다. 이렇게 이름 없이 선언한 함수를 익명 함수라고 부르며, ask 밖에서는 접근할 수 없다

- 함수 표현식은 실행 흐름이 해당 함수에 도달했을 때 함수를 생성하므로, 생성 이후부터 해당 함수를 사용할 수 있다. 반면 함수 선언문은 함수 선언문이 정의되기 전에도 호출할 수가 있다. 즉, 함수 선언문은 스크립트 내부 어디에서나 사용할 수가 있다


22. 화살표 함수(arrow function)

- 화살표 함수의 구조는 다음과 같다

let func = function(arg1, arg2, ...argN) {
  return expression;
};

let sum = (a, b) => a + b;

인수가 하나밖에 없다면 다음과 같이 인수를 감싸는 괄호를 생략할 수 있다

let double = n => n * 2;

- 화살표 함수에는 'this'가 없다

- 화살표 함수에는 'arguments'를 지원하지 않는다

- new와 함께 호출할 수 없다


23. 참조에 의한 객체 복사

- 객체와 원시 타입의 근본적인 차이 중 하나는 객체가 '참조에 의해' 저장되고 복사된다는 것이다. 객체는 객체가 그대로 저장되는 것이 아니라 메모리 주소인 객체에 대한 참조 값이 저장된다. 따라서 객체가 할당된 변수를 복사할 땐 객체의 참조 값이 복사되고 객체는 복사되지 않는다. 다음 예시를 보며 어떻게 동작하고 있는지 살펴보자

let user = { name: 'John' };

let admin = user;

admin.name = 'Pete'; // 'admin' 참조 값에 의해 변경됨

alert(user.name); // 'Pete'가 출력됨. 'user' 참조 값을 이용해 변경사항을 확인함

- 기존에 있던 객체와 똑같으면서도 독립적인 객체를 만들고 싶다면, 다음과 같은 방법을 사용한다

ㅇ 새로운 빈 객체를 만들고 빈 객체에 복사하고자 하는 객체의 프로퍼티를 모두 복사해 넣는다.

let user = {
  name: "John",
  age: 30
};

let clone = {}; // 새로운 빈 객체

// 빈 객체에 user 프로퍼티 전부를 복사해 넣습니다.
for (let key in user) {
  clone[key] = user[key];
}

// 이제 clone은 완전히 독립적인 복제본이 되었습니다.
clone.name = "Pete"; // clone의 데이터를 변경합니다.

alert( user.name ); // 기존 객체에는 여전히 John이 있습니다.

ㅇ Object.assign을 이용한다. Object.assign의 동작 방식은 다음과 같다

Object.assign(dest(복사당할 객체), [src1, src2, src3...](복사해 올 객체))

목표 객체(dest)에 동일한 이름을 가진 프로퍼티가 있는 경우엔 기존 값이 바뀐 값으로 덮어씌워진다

- 다른 객체에 의한 참조 값이 프로퍼티에 있을 수도 있다. 이런 경우에는 key의 값을 검사하면서, 그 값이 객체인 경우 객체의 구조도 복사해 주는 반복문을 사용해야 한다. 이것을 '깊은 복사'라고 한다


24. 가비지 컬렉션

- 자바스크립트는 눈에 보이지 않는 곳에서 메모리 관리를 수행한다. 메모리 관리는 도달 가능성이라는 개념을 기준으로 수행된다

- 다음의 값들은 태생부터 도달 가능한 값들이다

ㅇ 현재 함수의 지역 변수와 매개 변수
ㅇ 중첩 함수의 체인의 있는 함수에서 사용되는 변수와 매개 변수
ㅇ 전역 변수

이런 값들은 루트(root)라고 부른다

ㅇ 루트가 참조하는 값이나 체이닝으로 루트에서 참조할 수 있는 값은 도달 가능한 값이 된다


- 도달할 수 없는 값의 예시는 다음과 같다

let user = {
  name: "John",
}

user = null; 
을 하게 되면 name: "John"을 담고 있던 객체의 메모리가 가비지 컬렉터에 의해 삭제된다

